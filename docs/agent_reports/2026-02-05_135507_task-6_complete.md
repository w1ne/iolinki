# Task 6: Frame Synchronization + t_byte/t_bit Timing - Completion Report

**Agent:** Antigravity  
**Date:** 2026-02-05  
**Task:** Frame synchronization + t_byte/t_bit timing enforcement

## Summary

Successfully implemented frame synchronization and inter-byte timing enforcement in the IO-Link Data Link Layer. The implementation detects broken frames where bytes arrive with excessive delays (violation of UART frame continuity) and counts these occurrences for diagnostics.

## Implementation Details

### 1. Header Changes ([dll.h](file:///home/andrii/Projects/iolinki/include/iolinki/dll.h))

Added timing fields to `iolink_dll_ctx_t`:
- `last_byte_us` - Timestamp of last received byte
- `t_byte_limit_us` - Inter-byte timeout limit in microseconds
- `t_byte_violations` - Counter for inter-byte timing violations

Added `t_byte_violations` to `iolink_dll_stats_t` for external visibility.

### 2. DLL Implementation ([dll.c](file:///home/andrii/Projects/iolinki/src/dll.c))

**Helper Function:**
- `dll_get_t_byte_limit_us()` - Calculates inter-byte timeout based on baudrate
  - Formula: `(11 bits per byte + 5 bit tolerance) * t_bit`
  - COM1 (4.8 kbit/s): 208 µs/bit → 3,328 µs limit
  - COM2 (38.4 kbit/s): 26 µs/bit → 416 µs limit
  - COM3 (230.4 kbit/s): 4 µs/bit → 64 µs limit

<<<<<<< feature/task-6-frame-sync-timing
**Initialization:**
- Calculate `t_byte_limit_us` in `iolink_dll_init()`
- Initialize `last_byte_us` to 0

=======
>>>>>>> develop
**Runtime Checks:**
- In `iolink_dll_process()`, before processing each byte:
  - Check if we're mid-frame (`frame_index > 0`)
  - Calculate delta from last byte timestamp
  - If delta exceeds `t_byte_limit_us`:
    - Increment `t_byte_violations`, `timing_errors`, `framing_errors`
    - Trigger `IOLINK_EVENT_COMM_TIMING` event
    - Reset frame assembly (`frame_index = 0`)
  - Update `last_byte_us` timestamp

<<<<<<< feature/task-6-frame-sync-timing
**Baudrate Changes:**
- Updated `iolink_dll_set_baudrate()` to recalculate `t_byte_limit_us` when baudrate changes

**Stats Reporting:**
- Updated `iolink_dll_get_stats()` to include `t_byte_violations`

=======
>>>>>>> develop
### 3. Test Implementation ([test_timing.c](file:///home/andrii/Projects/iolinki/tests/test_timing.c))

Added `test_t_byte_violation()` test case:
- Moves device to OPERATE state
- Enables timing enforcement
- Sends first byte of a frame
- Delays 1ms (exceeds 416µs limit for COM2)
- Sends second byte
- Verifies `t_byte_violations > 0` and `timing_errors > 0`

## Verification Results

All tests passed successfully in Docker environment:

```
Test #10: test_timing ......................   Passed    0.07 sec
```
<<<<<<< feature/task-6-frame-sync-timing

The test suite includes:
- `test_time_get_ms` - Millisecond timing accuracy
- `test_time_get_us` - Microsecond timing accuracy
- `test_t_cycle_violation` - Minimum cycle time enforcement
- `test_t_ren_violation` - Response time limit enforcement
- `test_t_pd_delay` - Power-on delay enforcement
- `test_t_byte_violation` - **NEW** Inter-byte timing enforcement

## Files Modified

- [include/iolinki/dll.h](file:///home/andrii/Projects/iolinki/include/iolinki/dll.h#L79-L81) - Added timing fields to context and stats
- [src/dll.c](file:///home/andrii/Projects/iolinki/src/dll.c#L51-L80) - Implemented timing calculation and enforcement
- [tests/test_timing.c](file:///home/andrii/Projects/iolinki/tests/test_timing.c#L181-L226) - Added test case

## Acceptance Criteria

✅ Inter-byte timing violations are detected and counted  
✅ Unit tests cover at least one violation case  
✅ Tests pass in Docker environment

## Notes

- The 5-bit tolerance in the calculation accounts for clock drift and processing delay
- Timing enforcement is controlled by the `enforce_timing` flag (default: disabled)
- The implementation correctly handles frame reset on violation, treating the current byte as a potential new frame start
- The violation counter is exposed via the stats API for diagnostic purposes
=======
>>>>>>> develop
